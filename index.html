<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Seasonal Island Demo</title>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Open Sans', sans-serif;
    }

    canvas {
      display: block;
    }

    #seasonText {
      position: absolute;
      top: 53%;
      left: 15%;
      max-width: 25vw;
      text-align: left;
      font-size: 1.3em;
      font-weight: 400;
      line-height: 1.5em;
      color: white;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.85);
    }

    #titleText {
      position: absolute;
      top: 25%;
      left: 15%;
      font-size: 5em;
      font-weight: 400;
      color: white;
      line-height: 1em;
      text-align: left;
      text-shadow: 0 4px 10px rgba(0, 0, 0, 0.8);
      pointer-events: none;
    }

    #titleText br {
      display: block;
      content: "";
      margin-bottom: 0.3em;
    }

    #progressBarContainer {
      position: absolute;
      right: 100px;
      top: 10%;
      width: 10px;
      height: 70%;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      backdrop-filter: blur(6px);
    }

    #progressBar {
      width: 100%;
      height: 0%;
      background: white;
      border-radius: 5px;
      transition: height 0.2s ease;
    }

    #bottomGradient {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50%;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.7) 100%);
    }
  </style>
</head>

<body>
  <div id="titleText">Floating<br>Island</div>
  <div id="seasonText"></div>
  <div id="progressBarContainer">
    <div id="progressBar"></div>
  </div>
  <div id="bottomGradient"></div>
  
      <script>
        window.onerror = function(error, url, line) {
          parent.postMessage(["console", "\"Error on line[" + (line-1) + "]:" + error + "\""], "*")
        };
        window.addEventListener("unhandledrejection", function (event) {
          parent.postMessage(["console", "\"Error:Uncaught " + event.reason + "\""], "*")
        });
        function prettyPrint(obj, indent = 0, seen = new Map()) {
          
          let result = '';
          let baseIndent = ' '.repeat(indent);
          let newIndent = baseIndent + '    ';
          try {
          if (seen.has(obj)) {
              return `${baseIndent}"[Circular Reference (${seen.get(obj)})]"`;
          }
      
          if (typeof obj === 'object' && obj !== null) {
              seen.set(obj, seen.size + 1);
      
              if (Array.isArray(obj)) {
                  result += '[';
                  for (let i = 0; i < obj.length; i++) {
                      if (i > 0) {
                          result += ',';
                      }
                      const value = obj[i];
                      if (typeof value === 'object' && value !== null) {
                          result += '\n' + prettyPrint(value, indent + 4, seen);
                      } else if (typeof value === 'string') {
                          result += `\n${newIndent}"${value}"`;
                      } else if (typeof value === 'function') {
                        result += `\n${newIndent}"[Function]"`;
                      }  else if (value === undefined) {
                        result += `\n${newIndent}"[undefined]"`;
                      }
                      else {
                        result += `\n${newIndent}${value}`;
                      }
                  }
                  result += `\n${baseIndent}]`;
              } else {
                  result += '{\n';
                  let entries = Object.keys(obj).map((key) => {
                      const value = obj[key];
                      let entry = `${newIndent}"${key}": `;
                      if (typeof value === 'object' && value !== null) {
                          entry += prettyPrint(value, indent + 4, seen);
                      } else if (typeof value === 'string') {
                          entry += `"${value}"`;
                      } else if (typeof value === 'function') {
                        entry += `\n${newIndent}"[Function]"`;
                      } else if (value === undefined) {
                        entry += `\n${newIndent}"[undefined]"`;
                      } else {
                          entry += value;
                      }
      
                      return entry;
                  });
      
                  result += entries.join(',\n');
                  result += `\n${baseIndent}}`;
              }
          } else {
              if (typeof obj === 'string') {
                  result += `"${obj}"`;
              } else {
                  result += obj.toString();
              }
          }
        } catch (err) {
          result = "error making json string"
        }
      
          return result;
      }
       
</script><script crossorigin src="../libs/three.min.js">
</script>
  <script crossorigin src="../libs/GLTFLoader.js">
</script>
  <script crossorigin src="../libs/gsap.min.js">
</script>
  <script>
    let scene, camera, renderer;
    let sun;
    let currentIsland = null;
    let cloudLeft = null;
    let cloudRight = null;
    let leafObjects = [];
    let season = -1;

    let islandAngle = 0;
    let sunAngle = 0;
    let islandTurnProgress = 0;

    const TWO_PI = Math.PI * 2;
    const SUN_ISLAND_RATIO = 3;
    const SCROLL_SENSITIVITY = 0.0008;

    const seasonModels = [
      'https://raw.githubusercontent.com/RebeccaSY/seasons/main/models/island_spring.glb'
      'https://raw.githubusercontent.com/RebeccaSY/seasons/main/models/island_summer.glb'
      'https://raw.githubusercontent.com/RebeccaSY/seasons/main/models/island_autumn.glb'
      'https://raw.githubusercontent.com/RebeccaSY/seasons/main/models/island_winter.glb'
      'island_spring.glb',
      'island_summer.glb',
      'island_autumn.glb',
      'island_winter.glb'
    ];

    const seasonColors = [
      0xFFD1B2,
      0x87CEEB,
      0xF4C17A,
      0xD1DCE5
    ];

    const seasonTexts = [
      "Every beginning feels like Spring.<br>Hope takes root.",
      "Growth needs light.<br>In full bloom, we stretch toward the sun.",
      "Letting go is part of the cycle.<br>Beauty in change.",
      "Stillness has purpose.<br>In rest, we prepare to begin again."
    ];

    const progressBar = document.getElementById("progressBar");
    const seasonTextBox = document.getElementById("seasonText");

    const loader = new THREE.GLTFLoader();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x00172D);

      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1, 7);
      camera.lookAt(-1, 1, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      sun = new THREE.DirectionalLight(0xffa500, 1);
      sun.position.set(0, 50, 50);
      scene.add(sun);

      const ambient = new THREE.AmbientLight(0xffffff, 2);
      scene.add(ambient);

      document.addEventListener('wheel', onScroll, { passive: true });
      updateSeason();
      animate();
    }

    function createLeaves() {
      for (let i = 0; i < 12; i++) {
        loader.load('leaf.glb', function (gltf) {
          const leaf = gltf.scene;
          leaf.position.set(
            Math.random() * 2.2 - 0.5,
            1.8 + Math.random(),
            Math.random() - 0.5
          );
          leaf.rotation.set(Math.random(), Math.random(), Math.random());
          leaf.scale.set(0.05, 0.05, 0.05);
          leaf.userData.speed = 0.03 + Math.random() * 0.01;
          scene.add(leaf);
          leafObjects.push(leaf);
        });
      }
    }

    function updateLeaves() {
      leafObjects.forEach((leaf) => {
        leaf.position.y -= leaf.userData.speed;
        leaf.rotation.x += 0.03;
        leaf.rotation.y += 0.01;
        leaf.rotation.z += 0.03;
      });
    }

    function onScroll(event) {
      const delta = event.deltaY;
      if (delta > 0) {
        const islandStep = delta * SCROLL_SENSITIVITY;
        islandAngle += islandStep;
        islandTurnProgress += islandStep;
        const sunStep = islandStep * SUN_ISLAND_RATIO;
        sunAngle += sunStep;
        if (currentIsland) currentIsland.rotation.y = islandAngle;
        const radius = 30;
        sun.position.y = radius * Math.cos(sunAngle);
        sun.position.z = radius * Math.sin(sunAngle);
        const phase = (Math.sin(sunAngle) + 1) / 2;
        sun.color.setHSL(0.1 + 0.1 * phase, 1, 0.5 + 0.3 * phase);

        const fullRotationProgress = (islandTurnProgress % TWO_PI) / TWO_PI;
        const globalProgress = (season + fullRotationProgress) / 4;
        progressBar.style.height = `${globalProgress * 100}%`;

        if (season === 2) updateLeaves();

        if (islandTurnProgress >= TWO_PI) {
          islandTurnProgress -= TWO_PI;
          updateSeason();
        }
      }
    }

    function updateSeason() {
      season = (season + 1) % 4;
      const newColor = new THREE.Color(seasonColors[season]);
      gsap.to(scene.background, {
        r: newColor.r,
        g: newColor.g,
        b: newColor.b,
        duration: 2
      });

      loader.load(
        seasonModels[season],
        function (gltf) {
          const newIsland = gltf.scene;
          newIsland.position.set(0.5, 0, 0);
          newIsland.rotation.y = islandAngle;
          newIsland.scale.set(1, 1, 1);
          if (currentIsland) scene.remove(currentIsland);
          currentIsland = newIsland;
          scene.add(currentIsland);
        },
        undefined,
        function (error) {
          console.error(`Error loading model: ${seasonModels[season]}`, error);
parent.postMessage(["console",prettyPrint(`Error loading model: ${seasonModels[season]}`),prettyPrint(error)], "*");
        }
      );

      if (cloudLeft) scene.remove(cloudLeft);
      if (cloudRight) scene.remove(cloudRight);
      cloudLeft = null;
      cloudRight = null;

      leafObjects.forEach(leaf => scene.remove(leaf));
      leafObjects = [];

      if (season === 0 || season === 1) {
        loader.load('cloud.glb', function (gltf) {
          cloudLeft = gltf.scene.clone();
          cloudLeft.position.set(4.5, 4.2, -1);
          cloudLeft.rotation.set(0, TWO_PI/4, 0);
          cloudLeft.scale.set(0.3, 0.3, 0.3);
          scene.add(cloudLeft);

          cloudRight = gltf.scene.clone();
          cloudRight.position.set(-1.6, 3.9, -0.5);
          cloudRight.rotation.set(0, TWO_PI/4, 0);
          cloudRight.scale.set(0.2, 0.2, 0.2);
          scene.add(cloudRight);
        });
      }

      if (season === 2) createLeaves();
    }

    const originalUpdateSeason = updateSeason;
    updateSeason = function () {
      originalUpdateSeason();
      gsap.to(seasonTextBox, { opacity: 0, duration: 0.6 });
      setTimeout(() => {
        seasonTextBox.innerHTML = seasonTexts[season];
        gsap.to(seasonTextBox, { opacity: 1, duration: 1.2 });
      }, 600);
    };

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    init();
 
</script>
